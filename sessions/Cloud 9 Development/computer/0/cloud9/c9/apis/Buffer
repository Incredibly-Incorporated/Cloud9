--[[
Buffer API Documentation:

The buffer API is designed to handle all display
requests from APIs, scripts, and interfaces. The
solution to handle multiple display environments
is to provide one display table that will contain
children display tables that will be created by
the current executing script. 

Each display will hold an index in the C9_DISPLAY.
Each display index will hold {x} amount of indexes
which will depend on the size of the display.

Each pixel of the display contains its own table.
The table will contain the following indexes:
	> ["background_color"]
	> ["foreground_color"]
	> ["text"]

The namespace will contain the following layout:
	> [0] = {
		[1] = {
			["background_color"] = Reference.OS_DEFAULT_BACKGROUNDCOLOR;
			["foreground_color"] = Reference.OS_DEFAULT_FOREGROUNDCOLOR;
			["text"] = " ";
		};
		[2] = {
			["background_color"] = Reference.OS_DEFAULT_BACKGROUNDCOLOR;
			["foreground_color"] = Reference.OS_DEFAULT_FOREGROUNDCOLOR;
			["text"] = " ";
		};
	};

The parent table will be controlled by the
framework, which can be accessed globally by the
executing terminal. 

Refer to the documentation to use this powerful
API correctly.
<>
]]

--[[
Namespace: 'C9_DISPLAY', Documentation:

This namespace is used as the parent of all
corresponding children that will be passed to
the main display. To wrap your head around this
refer to the documentation above.
<>
]]

C9_DISPLAY = {}
C9_DISPLAY.TERMINAL = {}
C9_DISPLAY.TERMINAL.PROTOTYPE = {
	index = 0;
	width = 10;
	height = 10;
	text = " ";
	background = Reference.OS_DEFAULT_BACKGROUNDCOLOR;
	foreground = Reference.OS_DEFAULT_FOREGROUNDCOLOR;
}
C9_DISPLAY.TERMINAL.mt = {
	__index = C9_DISPLAY.TERMINAL.PROTOTYPE
}

-- ============= -- LOCAL ZONE -- ============= --
--[[
The following functions are local to this API.
They will not be needed in your terminals, they
are simply here to shorten the size of this file,
and keep the code clean.
<>
]]

local function DRAW_TERMINAL()
	-- # Declaring Local Variables:
	local w, h = term.getSize()

	-- # Code:
	for i = 1, h do
		for k = 1, w do
			term.setCursorPos(i, h)
			-- LASTEST DEV:
			-- Determine the best way of writing pixels, and storing their data
			-- a master table that can be referred to, so that it can be determined
			-- if new data needs to be overridden.
		end
	end
end

-- =========== -- END LOCAL ZONE -- =========== --

--[[
Function Table Documentation:

This table is used to manage the terminal via this
API. The functions will be documented within the
table.
<>
]]

local _FUNCTIONS = {
	
	--[[
	// Function: 'display', Documentation:
	//
	// This function is used to display the terminal to the
	// main display. It will check what pixels need updated.
	//
	// > Arguments:
	//
	// [object] : "The terminal object."
	// [visible]: "Whether or not to update the display."
	//
	// > Returns:
	// [N/A]: "No returns are available for this function."
	// <>
	]]

	display = function(object, visible)
		-- # Checking Variables:
		if type(visible) ~= "boolean" then error("Visibility must be true or false!", 2) end

		-- # Declaring Local Variables:
		-- N/A

		-- # Code:

	end;
}

--[[
Function: 'new', Documentation:

This function is used to provide an object in
which the user can manage a terminal in the 
display buffer. 

> Arguments:

[object]: "The table object you want to have
           in OOP format."

> Returns:
[object]: "The provided table will be returned
           in OOP format."
<>
]]

function new(object)
	if object and type(object) ~= "table" then
		error("The provided argument must be a table!", 2)
	end

	if object then
		setmetatable(object, C9_DISPLAY.TERMINAL.mt)

		for k, v in pairs(_FUNCTIONS) do
			object[k] = v
		end

		return object
	else
		local NEW_TERMINAL = {}

		setmetatable(NEW_TERMINAL, C9_DISPLAY.TERMINAL.mt)

		for k, v in pairs(_FUNCTIONS) do
			NEW_TERMINAL[k] = v
		end

		return NEW_TERMINAL
	end
end

-- End of Document